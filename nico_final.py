# -*- coding: utf-8 -*-
"""nico_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ta4igEDZ3OzsfkhwOtNOAAS4HxkGOLJh
"""

# !pip install gradient-descent

import math
import random
import numpy as np
import matplotlib.pyplot as plt

"""## Helper Functions"""

def init_N_points(N, xdim, ydim):
  # currently set up for an open space
  points = [[0,0]]
  points = np.empty((0,2), int)
  for i in range(N):
    points2add = np.array([[random.randint(0, xdim), random.randint(0, ydim)]])
    points = np.append(points, points2add, axis=0)
  return points

def compute_nearest_distance_grid(xdim, ydim, stations):
  # compute distance to nearest station from each point (L2 norm)
  distance_arr = (xdim*ydim)*np.ones((xdim,ydim))  # initialize nearest distance to a large value
  for y in range(ydim):
    for x in range(xdim):
      curr_point = [x,y]
      nearest_distance = distance_arr[x,y] # initialize nearest distance to a large value
      for pt in stations:
        curr_station = pt # loops through each station
        distance = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(curr_point, curr_station)))
        if distance < nearest_distance: # if this station is closer than any previous,
          nearest_distance = distance # then it's the new best
      distance_arr[x,y] = nearest_distance
    # if y % (round(ydim/10)) == 0: # print every few rows
    #   print('Finished row:',y,'/',ydim)
  return distance_arr

def compute_coverage(distance_arr, coverage_range):
  # compute coverage
  coverage_mask = distance_arr <= coverage_range
  coverage = coverage_mask.sum()/(xdim*ydim)
  return coverage

def compute_score_and_penalty(distance_arr,coverage_range):
  score = 0
  for x in range(np.shape(distance_arr)[0]):
    for y in range(np.shape(distance_arr)[1]):
      curr_value = distance_arr[x,y]
      if curr_value <= coverage_range:
        # score += curr_value
        score += 0
      else:
        # score += curr_value + (curr_value-coverage_range)**2
        score += curr_value + (curr_value)**2 # this is an alternative, stricter penalty
  return score

def fx(N, xdim, ydim, coverage_range, points):
  distance_arr = compute_nearest_distance_grid(xdim, ydim, points)
  coverage = compute_coverage(distance_arr, coverage_range)
  score = compute_score_and_penalty(distance_arr,coverage_range)
  return score, distance_arr, coverage

"""## Main Function"""

# score = fx(points) # minimize this score!!

def wiggle_the_points(N, xdim, ydim, coverage_range, alpha, max_iter):
  # random initialization - these must match the values hard coded in fx(points)
  init_points = init_N_points(N, xdim, ydim)
  init_score, init_dist_array, init_coverage = fx(N, xdim, ydim, coverage_range, init_points)

  # initialize
  points = init_points
  score = init_score

  point_storage = init_points

  # hyperparamters
  # alpha = 10
  # max_iter = 50
  for iter in range(max_iter): # mesh-adaptive direct search (Stochastic Methods)
    # randomly move a point and update
    N = np.shape(points)[0]
    num_expansions = np.shape(init_points)[1] # expand in each of the two coord directions
    
    # choose one of the N points at random
    pt2explore = random.choice(points)

    # step alpha in each coordinate direction and reevaluate
    pt2explore1 = [pt2explore[0]+alpha, pt2explore[1]]
    pt2explore2 = [pt2explore[0]-alpha, pt2explore[1]]
    pt2explore3 = [pt2explore[0], pt2explore[1]+alpha]
    pt2explore4 = [pt2explore[0], pt2explore[1]-alpha]

    # check that no points went out of bounds, otherwise ignore it
    if pt2explore1[0] >= xdim or pt2explore1[0] < 0 or pt2explore1[1] >= ydim or pt2explore1[1] < 0:
      pt2explore1 = pt2explore
    if pt2explore2[0] >= xdim or pt2explore2[0] < 0 or pt2explore2[1] >= ydim or pt2explore2[1] < 0:
      pt2explore2 = pt2explore
    if pt2explore3[0] >= xdim or pt2explore3[0] < 0 or pt2explore3[1] >= ydim or pt2explore3[1] < 0:
      pt2explore3 = pt2explore
    if pt2explore4[0] >= xdim or pt2explore4[0] < 0 or pt2explore4[1] >= ydim or pt2explore4[1] < 0:
      pt2explore4 = pt2explore

    # THIS SOMETIMES ERRORS WHEN VALUES ARE ALONG THE SAME ROW/COL as here:
    #   this is mask: [[False False]
    #     [False False]
    #     [ True False]
    #     [ True  True]
    #     [False False]]
    # replace the pt in points array
    mask = (points == pt2explore)
    pts2explore1 = np.copy(points)
    # print('this is pt2explore1:',pt2explore1)
    # print('this is pts2explore1:',pts2explore1)
    # print('this is mask:',mask)
    pts2explore1[mask] = pt2explore1

    pts2explore2 = np.copy(points)
    pts2explore2[mask] = pt2explore2

    pts2explore3 = np.copy(points)
    pts2explore3[mask] = pt2explore3

    pts2explore4 = np.copy(points)
    pts2explore4[mask] = pt2explore4

    # calculate the new state for each exploration direction
    upd_score1, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore1)
    upd_score2, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore2)
    upd_score3, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore3)
    upd_score4, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore4)

    # compare and see which is the best direction to go in (or whether to stay)
    new_scores = np.array([score, upd_score1, upd_score2, upd_score3, upd_score4])
    best_scorearg = np.argmin(new_scores)
    best_score = min(new_scores)

    # if best_scorearg == 0, there's no improvement, otherwise, the new points are chosen
    eligible_advances = [points, pts2explore1, pts2explore2, pts2explore3, pts2explore4]
    points = eligible_advances[best_scorearg]
    point_storage = np.append(point_storage, points,axis = 0)
    print('Just finished iteration:',iter+1,'/',max_iter)

  # the final values
  final_score, final_dist_array, final_coverage = fx(N, xdim, ydim, coverage_range, points)
  return init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points

# score = fx(points) # minimize this score!!

def wiggle_the_points2(N, xdim, ydim, coverage_range, alpha, max_iter, threshold):
  # random initialization - these must match the values hard coded in fx(points)
  init_points = init_N_points(N, xdim, ydim)
  init_score, init_dist_array, init_coverage = fx(N, xdim, ydim, coverage_range, init_points)

  # initialize
  points = init_points
  score = init_score

  point_storage = init_points
  old_best_scores = np.array([9e9])

  # hyperparamters
  # alpha = 10
  # max_iter = 50
  converged = False
  iter = 0
  # for iter in range(max_iter): # mesh-adaptive direct search (Stochastic Methods)
  while not converged and iter < max_iter:
    # print('condition 1:', not converged)
    # print('condition 2:', iter > max_iter)
    
    # randomly move a point and update
    N = np.shape(points)[0]
    num_expansions = np.shape(init_points)[1] # expand in each of the two coord directions
    
    # choose one of the N points at random
    pt2explore = random.choice(points)

    # step alpha in each coordinate direction and reevaluate
    pt2explore1 = [pt2explore[0]+alpha, pt2explore[1]]
    pt2explore2 = [pt2explore[0]-alpha, pt2explore[1]]
    pt2explore3 = [pt2explore[0], pt2explore[1]+alpha]
    pt2explore4 = [pt2explore[0], pt2explore[1]-alpha]

    # check that no points went out of bounds, otherwise ignore it
    if pt2explore1[0] >= xdim or pt2explore1[0] < 0 or pt2explore1[1] >= ydim or pt2explore1[1] < 0:
      pt2explore1 = pt2explore
    if pt2explore2[0] >= xdim or pt2explore2[0] < 0 or pt2explore2[1] >= ydim or pt2explore2[1] < 0:
      pt2explore2 = pt2explore
    if pt2explore3[0] >= xdim or pt2explore3[0] < 0 or pt2explore3[1] >= ydim or pt2explore3[1] < 0:
      pt2explore3 = pt2explore
    if pt2explore4[0] >= xdim or pt2explore4[0] < 0 or pt2explore4[1] >= ydim or pt2explore4[1] < 0:
      pt2explore4 = pt2explore

    # THIS SOMETIMES ERRORS WHEN VALUES ARE ALONG THE SAME ROW/COL as here:
    #   this is mask: [[False False]
    #     [False False]
    #     [ True False]
    #     [ True  True]
    #     [False False]]
    # replace the pt in points array
    mask = (points == pt2explore)
    pts2explore1 = np.copy(points)
    # print('this is pt2explore1:',pt2explore1)
    # print('this is pts2explore1:',pts2explore1)
    # print('this is mask:',mask)
    pts2explore1[mask] = pt2explore1

    pts2explore2 = np.copy(points)
    pts2explore2[mask] = pt2explore2

    pts2explore3 = np.copy(points)
    pts2explore3[mask] = pt2explore3

    pts2explore4 = np.copy(points)
    pts2explore4[mask] = pt2explore4

    # calculate the new state for each exploration direction
    upd_score1, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore1)
    upd_score2, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore2)
    upd_score3, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore3)
    upd_score4, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore4)

    # compare and see which is the best direction to go in (or whether to stay)
    new_scores = np.array([score, upd_score1, upd_score2, upd_score3, upd_score4])
    best_scorearg = np.argmin(new_scores)
    best_score = min(new_scores)
    old_best_scores = np.append(old_best_scores, best_score)

    # if best_scorearg == 0, there's no improvement, otherwise, the new points are chosen
    eligible_advances = [points, pts2explore1, pts2explore2, pts2explore3, pts2explore4]
    points = eligible_advances[best_scorearg]
    point_storage = np.append(point_storage, points,axis = 0)

    iter += 1
    print('Just finished iteration:',iter)
    # print('this is old_best_scores[:-1]',old_best_scores[:-1])
    # print('this is old_best_scores[:-2]',old_best_scores[:-2])
    # print('this is best_scores:', best_score)
    print('this is the difference:',abs(old_best_scores[-1] - old_best_scores[-2]))
    if abs(old_best_scores[-1] - old_best_scores[-2]) < threshold:
      converged = True
    elif coverage == 1.0:
      converged = True
      print('Perfect coverage!')
  print('Converged in',iter,'iterations.')

  # the final values
  final_score, final_dist_array, final_coverage = fx(N, xdim, ydim, coverage_range, points)
  return init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points

"""## Notes
* 50 iterations, N = 3, alpha = 10, 100x100 , the loop above took 59 seconds
* 20 iterations, N = 5, alpha = 10, 100x100 , the loop above took 42 seconds
* 20 iterations, N = 5, alpha = 10, 100x100 , the loop above took 34 seconds
* 50 iterations, N = 5, alpha = 10, 200x200 , the loop above took 5 minutes
* 30 iterations, N = 5, alpha = 5, 200x200 , the loop above took 3 minutes 22 seconds
* 10 iterations, N = 5, alpha = 5, 200x200 , the loop above took 1 minute 27 seconds

* **Test 1**: 50 iterations, N = 5, alpha = 10, 200x200, the loop above took 6 minutes 5 seconds, coverage_range = 30
* **Test 2**: 20 iterations, N = 5, alpha = 10, 100x100, the loop above took 36 seconds, coverage_range = 30
* **Test 3**: 50 iterations, N = 5, alpha = 10, 100x100, the loop above took X seconds, coverage_range = 30
* **Test 4**: converge in 33 iterations, N = 5, alpha = 10, 100x100, the loop above took X seconds, coverage_range = 30, threshold = 100
* **Test 5**: converge in 23 iterations, N = 9, alpha = 10, 100x100, the loop above took 68 seconds, coverage_range = 30, threshold = 100
* **Test 6**: converge in 11 iterations, N = 5, alpha = 10, 200x200, the loop above took 60 seconds, coverage_range = 100, threshold = 1000
* **Test 7**: converge in 10 iterations, N = 5, alpha = 10, 100x100, the loop above took 17 seconds, coverage_range = 50, threshold = 500, using bigger penalty. Perfect coverage!

TODO: IF LAST 5, 10, ITERATIONS HAD THE SAME SCORE, THEN END ITERATIONS? - SOME SORT OF CONVERGENCE CRITERION
"""

N = 5
xdim = 200
ydim = 200
coverage_range = 30
alpha = 10
max_iter = 50
threshold = 1000
# init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points = wiggle_the_points(N, xdim, ydim, coverage_range, alpha, max_iter)
init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverag, points = wiggle_the_points2(N, xdim, ydim, coverage_range, alpha, max_iter, threshold)

"""## Plotting"""

plt.contourf(init_dist_array) # plot filled background contour
plt.colorbar() # add the colorbar
plt.contour(init_dist_array, [coverage_range], colors='red') # plot the red range limits
for i in range(np.shape(init_points)[0]): # for each station, i
  plt.scatter(init_points[i][1],init_points[i][0]) # plot the station's coordinates
plt.axis('equal')
print('Initial coverage:',init_coverage)

plt.contourf(final_dist_array) # plot filled background contour
plt.colorbar() # add the colorbar
plt.contour(final_dist_array, [coverage_range], colors='red') # plot the red range limits
for i in range(np.shape(points)[0]): # for each station, i
  plt.scatter(points[i][1],points[i][0]) # plot the station's coordinates
plt.axis('equal')
print('Final coverage:',final_coverage)

"""## Original Test"""

# # set parameters
# N = 2   # number of stations
# ydim = 100 # y-dimension of the search space
# xdim = 100 # x-dimension of the search space
# coverage_range = 20 # range of each station

# init_points = init_N_points(N, xdim, ydim)
# distance_arr, coverage, stations, goodness_score = wiggle_the_pointsOLD(N, xdim, ydim, coverage_range, init_points, 20)

# print(coverage)

# plt.contourf(distance_arr) # plot filled background contour
# plt.colorbar() # add the colorbar
# plt.contour(distance_arr, [coverage_range], colors='red') # plot the red range limits
# for i in range(np.shape(stations)[0]): # for each station, i
#   plt.scatter(stations[i][1],stations[i][0]) # plot the station's coordinates
# plt.axis('equal')
# # plt.grid('both') # add gridlines but they look ugly

# # FUNCTION NOT USED - depricated
# def wiggle_the_pointsOLD(N, xdim, ydim, coverage_range, points):
#   distance_arr = compute_nearest_distance_grid(xdim, ydim, init_points)
#   coverage = compute_coverage(distance_arr, coverage_range)

#   goodness_score = 1 #compute_score_and_penalty(distance_arr,coverage_range)

#   stations = init_points
#   # TODO: wiggle the points with a penalty (make another function)
#   return distance_arr, coverage, stations, goodness_score

# # https://github.com/DanielDaCosta/gradient-descent/blob/master/Example_Algo_optimizations.ipynb
# from optimizationAlgorithms import GradientDescent

# gd = GradientDescent(f, df, x_t=[], learning_rate = 0.1)
# gd.fit()
# gd.get_n_iteration()
# gd.plot_optimization(x1 = -10, x2 = 10)