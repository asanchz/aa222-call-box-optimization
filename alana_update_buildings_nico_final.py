# -*- coding: utf-8 -*-
"""alana_update_buildings_nico_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yg6cAPnjfLu4YViSnBp4qFuxfHlQzYTv
"""

# !pip install gradient-descent

import math
import random
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
import matplotlib.patches as patches
import pandas as pd

"""## Helper Functions"""

def init_N_points(N, xdim, ydim, occupied = None):
  # currently set up for an open space
  points = [[0,0]]
  points = np.empty((0,2), int)

  exclude = np.where(occupied == 1)
  ex_x = exclude[0]
  ex_y = exclude[1]
  ex = []
  for k in range(len(ex_x)):
    ex.append([ex_x[k],ex_y[k]])
  i = 0
  while i < N:
    x = random.randint(0, xdim)
    y = random.randint(0, ydim)
    if (x,y) in ex:
      continue
    points2add = np.array([[x,y]])
    points = np.append(points, points2add, axis=0)
    i+=1
  return points

def compute_nearest_distance_grid(xdim, ydim, stations, occupied = None):
  # compute distance to nearest station from each point (L2 norm)
  distance_arr = (xdim*ydim)*np.ones((xdim,ydim))  # initialize nearest distance to a large value
  for y in range(ydim):
    for x in range(xdim):
      curr_point = [x,y]
      nearest_distance = distance_arr[x,y] # initialize nearest distance to a large value
      for pt in stations:
        curr_station = pt # loops through each station
        distance = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(curr_point, curr_station)))

        #checking if it intercepts a building
        points_crossed = []
        step = (pt[0]-curr_point[0])/xdim
        slope = (pt[1]-curr_point[1])/(pt[0]-curr_point[0]) #get slope between points
        for i in range(xdim):
            dx = i*step + x
            dy = i*slope*step + y
            points_crossed.append([dx,dy])
        points_crossed = np.trunc(points_crossed)
        exclude = np.where(occupied == 1)
        ex_x = exclude[0]
        ex_y = exclude[1]
        ex = []
        for k in range(len(ex_x)):
          ex.append([ex_x[k],ex_y[k]])

        check = (ex==points_crossed[:,None]).all(-1).any()
        if check:
          continue

        #if (distance < nearest_distance) & (not any(contained)): # if this station is closer than any previous,
        if (distance < nearest_distance):
          nearest_distance = distance # then it's the new best
      distance_arr[x,y] = nearest_distance
    # if y % (round(ydim/10)) == 0: # print every few rows
    #   print('Finished row:',y,'/',ydim)
  return distance_arr

def compute_coverage(distance_arr, coverage_range):
  # compute coverage
  coverage_mask = distance_arr <= coverage_range
  coverage = coverage_mask.sum()/(xdim*ydim)
  return coverage

def compute_score_and_penalty(distance_arr,coverage_range):
  score = 0
  for x in range(np.shape(distance_arr)[0]):
    for y in range(np.shape(distance_arr)[1]):
      curr_value = distance_arr[x,y]
      if curr_value <= coverage_range:
        # score += curr_value
        score += 0
      else:
        # score += curr_value + (curr_value-coverage_range)**2
        score += curr_value + (curr_value)**2 # this is an alternative, stricter penalty
  return score

def fx(N, xdim, ydim, coverage_range, points, occupied):
  distance_arr = compute_nearest_distance_grid(xdim, ydim, points, occupied = occupied)
  coverage = compute_coverage(distance_arr, coverage_range)
  score = compute_score_and_penalty(distance_arr,coverage_range)
  return score, distance_arr, coverage

# Alana section
def add_buildings(W, xdim, ydim, dimensions, left_top_positions):
  # let's say building side lengths between 30-100 meters and they are rectangular
  # 1 pixel in grid = 1 meters
  '''
  W = number of buildings
  xdim = x-dimension of grid space
  ydim = y-dimension of grid space
  dimensions = size of building (x,y) in integer vals
  left_top_positions = top left corner (x,y) of building
  '''
  occupied = np.zeros((xdim,ydim), dtype=int)
  for g in range(len(left_top_positions)):
    for i in range(dimensions[g][0]): #xvals
      for j in range(dimensions[g][1]):
        occupied[j+left_top_positions[g][1]][i+left_top_positions[g][0]] = 1.

  return occupied

"""## Main Function"""

# score = fx(points) # minimize this score!!

def wiggle_the_points2(N, xdim, ydim, coverage_range, alpha, max_iter, threshold, W, dimensions, left_top_positions):
  # random initialization - these must match the values hard coded in fx(points)
  building_grid = add_buildings(W, xdim, ydim, dimensions, left_top_positions)
  init_points = init_N_points(N, xdim, ydim, occupied = building_grid)
  init_score, init_dist_array, init_coverage = fx(N, xdim, ydim, coverage_range, init_points, building_grid)

  # initialize
  points = init_points
  score = init_score

  point_storage = init_points
  old_best_scores = np.array([9e9])

  # hyperparamters
  # alpha = 10
  # max_iter = 50
  converged = False
  iter = 0
  # for iter in range(max_iter): # mesh-adaptive direct search (Stochastic Methods)
  while not converged and iter < max_iter:
    # print('condition 1:', not converged)
    # print('condition 2:', iter > max_iter)
    
    # randomly move a point and update
    N = np.shape(points)[0]
    num_expansions = np.shape(init_points)[1] # expand in each of the two coord directions
    
    # choose one of the N points at random
    pt2explore = random.choice(points)

    # step alpha in each coordinate direction and reevaluate
    pt2explore1 = [pt2explore[0]+alpha, pt2explore[1]]
    pt2explore2 = [pt2explore[0]-alpha, pt2explore[1]]
    pt2explore3 = [pt2explore[0], pt2explore[1]+alpha]
    pt2explore4 = [pt2explore[0], pt2explore[1]-alpha]

    # check that no points went out of bounds, otherwise ignore it
    if pt2explore1[0] >= xdim or pt2explore1[0] < 0 or pt2explore1[1] >= ydim or pt2explore1[1] < 0:
      pt2explore1 = pt2explore
    if pt2explore2[0] >= xdim or pt2explore2[0] < 0 or pt2explore2[1] >= ydim or pt2explore2[1] < 0:
      pt2explore2 = pt2explore
    if pt2explore3[0] >= xdim or pt2explore3[0] < 0 or pt2explore3[1] >= ydim or pt2explore3[1] < 0:
      pt2explore3 = pt2explore
    if pt2explore4[0] >= xdim or pt2explore4[0] < 0 or pt2explore4[1] >= ydim or pt2explore4[1] < 0:
      pt2explore4 = pt2explore

    # THIS SOMETIMES ERRORS WHEN VALUES ARE ALONG THE SAME ROW/COL as here:
    #   this is mask: [[False False]
    #     [False False]
    #     [ True False]
    #     [ True  True]
    #     [False False]]
    # replace the pt in points array
    mask = (points == pt2explore)
    pts2explore1 = np.copy(points)
    # print('this is pt2explore1:',pt2explore1)
    # print('this is pts2explore1:',pts2explore1)
    # print('this is mask:',mask)
    pts2explore1[mask] = pt2explore1

    pts2explore2 = np.copy(points)
    pts2explore2[mask] = pt2explore2

    pts2explore3 = np.copy(points)
    pts2explore3[mask] = pt2explore3

    pts2explore4 = np.copy(points)
    pts2explore4[mask] = pt2explore4

    # calculate the new state for each exploration direction
    upd_score1, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore1, building_grid)
    upd_score2, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore2, building_grid)
    upd_score3, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore3, building_grid)
    upd_score4, distance_arr, coverage = fx(N, xdim, ydim, coverage_range, pts2explore4, building_grid)

    # compare and see which is the best direction to go in (or whether to stay)
    new_scores = np.array([score, upd_score1, upd_score2, upd_score3, upd_score4])
    best_scorearg = np.argmin(new_scores)
    best_score = min(new_scores)
    old_best_scores = np.append(old_best_scores, best_score)

    # if best_scorearg == 0, there's no improvement, otherwise, the new points are chosen
    eligible_advances = [points, pts2explore1, pts2explore2, pts2explore3, pts2explore4]
    points = eligible_advances[best_scorearg]
    point_storage = np.append(point_storage, points,axis = 0)

    iter += 1
    print('Just finished iteration:',iter)
    # print('this is old_best_scores[:-1]',old_best_scores[:-1])
    # print('this is old_best_scores[:-2]',old_best_scores[:-2])
    # print('this is best_scores:', best_score)
    print('this is the difference:',abs(old_best_scores[-1] - old_best_scores[-2]))
    if abs(old_best_scores[-1] - old_best_scores[-2]) < threshold:
      converged = True
    elif coverage == 1.0:
      converged = True
      print('Perfect coverage!')
  print('Converged in',iter,'iterations.')

  # the final values
  final_score, final_dist_array, final_coverage = fx(N, xdim, ydim, coverage_range, points, building_grid)
  return init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points, building_grid

"""## Notes
* 50 iterations, N = 3, alpha = 10, 100x100 , the loop above took 59 seconds
* 20 iterations, N = 5, alpha = 10, 100x100 , the loop above took 42 seconds
* 20 iterations, N = 5, alpha = 10, 100x100 , the loop above took 34 seconds
* 50 iterations, N = 5, alpha = 10, 200x200 , the loop above took 5 minutes
* 30 iterations, N = 5, alpha = 5, 200x200 , the loop above took 3 minutes 22 seconds
* 10 iterations, N = 5, alpha = 5, 200x200 , the loop above took 1 minute 27 seconds

* **Test 1**: 50 iterations, N = 5, alpha = 10, 200x200, the loop above took 6 minutes 5 seconds, coverage_range = 30
* **Test 2**: 20 iterations, N = 5, alpha = 10, 100x100, the loop above took 36 seconds, coverage_range = 30
* **Test 3**: 50 iterations, N = 5, alpha = 10, 100x100, the loop above took X seconds, coverage_range = 30
* **Test 4**: converge in 33 iterations, N = 5, alpha = 10, 100x100, the loop above took X seconds, coverage_range = 30, threshold = 100
* **Test 5**: converge in 23 iterations, N = 9, alpha = 10, 100x100, the loop above took 68 seconds, coverage_range = 30, threshold = 100
* **Test 6**: converge in 11 iterations, N = 5, alpha = 10, 200x200, the loop above took 60 seconds, coverage_range = 100, threshold = 1000
* **Test 7**: converge in 10 iterations, N = 5, alpha = 10, 100x100, the loop above took 17 seconds, coverage_range = 50, threshold = 500, using bigger penalty. Perfect coverage!

TODO: IF LAST 5, 10, ITERATIONS HAD THE SAME SCORE, THEN END ITERATIONS? - SOME SORT OF CONVERGENCE CRITERION
"""

N = 3
xdim = 100
ydim = 100
coverage_range = 30
alpha = 10
max_iter = 50
threshold = 1000
#W = 1
#dimensions = [[40,30]]
#left_top_positions = [[10,60]]
W = 2
dimensions = [[20,30],[60,30]]
left_top_positions = [[10,10],[30,60]]
# init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points = wiggle_the_points(N, xdim, ydim, coverage_range, alpha, max_iter)
init_score, init_dist_array, init_coverage, init_points, final_score, final_dist_array, final_coverage, points, building_grid = wiggle_the_points2(N, xdim, ydim, coverage_range, alpha, max_iter, threshold, W, dimensions, left_top_positions)

"""## Alana Updates with buildings
**1 building**
* converged in 9 iterations, N = 5, alpha = 10, 100x100, still running
* **to do**: N = 3, 100x100

**2 buildings**
* max 50 iter, N = 3, alpha = 10, 100x100
* max 50 iter, N = 5, alpha = 10, 100x100

**3 buildings**
* max 50 iter, N = 3, alpha = 10, 100x100
* max 50 iter, N = 5, alpha = 10, 100x100

## Plotting
"""

levels = np.linspace(0,100,10)
fig = plt.contourf(init_dist_array,levels=levels,extend="both", cmap='viridis') # plot filled background contour
fig.cmap.set_over(color='k')


plt.colorbar() # add the colorbar
plt.contour(init_dist_array, [coverage_range], colors='red') # plot the red range limits
for i in range(np.shape(init_points)[0]): # for each station, i
  plt.scatter(init_points[i][1],init_points[i][0]) # plot the station's coordinates

rect = patches.Rectangle((10, 60), 40, 30, linewidth=1, edgecolor='k', facecolor='darkorange',zorder=2)
plt.gca().add_patch(rect)

plt.axis('equal')
print('Initial coverage:',init_coverage)

levels = np.linspace(0,100,10)
plt.contourf(final_dist_array,levels=levels,extend="both", cmap='viridis') # plot filled background contour
fig.cmap.set_over(color='k')
plt.colorbar() # add the colorbar
plt.contour(final_dist_array, [coverage_range], colors='red') # plot the red range limits
for i in range(np.shape(points)[0]): # for each station, i
  plt.scatter(points[i][1],points[i][0]) # plot the station's coordinates

rect = patches.Rectangle((10, 60), 40, 30, linewidth=1, edgecolor='k', facecolor='darkorange',zorder=2)
plt.gca().add_patch(rect)

plt.axis('equal')
print('Final coverage:',final_coverage)

"""## Original Test

Building Tests
"""

N = 3
test = add_buildings(1, 100, 100, dim_1, left_top_1)
test2 = init_N_points(N, 100, 100, occupied = test)
print(test2)

from matplotlib import colors
from matplotlib import pyplot
colormap = colors.ListedColormap(["white","lightgreen"])

# Case params w/ buildings
W_1 = 1
dim_1 = [[40,30]]
left_top_1 = [[10,60]]

W_2 = 2
dim_2 = [[20,30],[60,30]]
left_top_2 = [[10,10],[30,60]]

W_3 = 3
dim_3 = [[30,40],[40,30],[60,20]]
left_top_3 = [[10,10],[50,20],[20,60]]

test = add_buildings(W_1, 100, 100, dim_1, left_top_1)
pyplot.figure(figsize=(5,5))
pyplot.imshow(test,
             cmap=colormap)
pyplot.xlabel("x",size = 14)
pyplot.ylabel("y",size = 14)
pyplot.grid(which='both')
pyplot.title('Case 1, one building')
pyplot.show()

print(test)