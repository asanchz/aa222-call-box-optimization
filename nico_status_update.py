# -*- coding: utf-8 -*-
"""nico_status_update.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i-nmOxDINeicKr4Kduh9A3ydsVFtaHDj
"""

import math
import random
import numpy as np
import matplotlib.pyplot as plt

def init_N_points(N, xdim, ydim):
  # currently set up for an open space
  points = [[0,0]]
  points = np.empty((0,2), int)
  for i in range(N):
    points2add = np.array([[random.randint(0, xdim), random.randint(0, ydim)]])
    points = np.append(points, points2add, axis=0)
  return points
# init_points = init_N_points(4, 100, 100)

def wiggle_the_points(N, xdim, ydim, coverage_range):
  # initialize N points
  init_points = init_N_points(N, xdim, ydim)
  # init_points = [[30, 11], [15,40]]

  # compute distance to nearest station from each point (L2 norm)
  distance_arr = (xdim*ydim)*np.ones((xdim,ydim))  # initialize nearest distance to a large value
  for y in range(ydim):
    for x in range(xdim):
      curr_point = [x,y]
      nearest_distance = distance_arr[x,y] # initialize nearest distance to a large value
      for pt in init_points:
        curr_station = pt # loops through each station
        distance = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(curr_point, curr_station)))
        if distance < nearest_distance: # if this station is closer than any previous,
          nearest_distance = distance # then it's the new best
      distance_arr[x,y] = nearest_distance
    if y % (round(ydim/10)) == 0: # print every few rows
      print('Finished row:',y,'/',ydim)

  # compute coverage
  coverage_mask = distance_arr <= coverage_range
  coverage = coverage_mask.sum()/(xdim*ydim)

  stations = init_points
  # TODO: wiggle the points with a penalty (make another function)
  return distance_arr, coverage, stations

# set parameters
N = 2   # number of stations
ydim = 500 # y-dimension of the search space
xdim = 1000 # x-dimension of the search space
coverage_range = 10 # range of each station

distance_arr, coverage, stations = wiggle_the_points(N, xdim, ydim, coverage_range)

print(coverage)

plt.contourf(distance_arr) # plot filled background contour
plt.colorbar() # add the colorbar
plt.contour(distance_arr,[coverage_range],colors='red') # plot the red range limits
for i in range(np.shape(stations)[0]): # for each station, i
  plt.scatter(stations[i][1],stations[i][0]) # plot the station's coordinates
# TODO: make the figure a square

# !python --version